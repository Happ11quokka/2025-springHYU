# 자료구조 및 알고리즘 구현 모음

CSE2010-자료구조론 한양대학교 박종우 교수님 강의를 수강하면서 정리한 내용입니다. 감사합니다. 


## 📚 목차

1. [트리 구조 (Trees)](#트리-구조-trees)
2. [힙 (Heap)](#힙-heap)
3. [그래프 (Graph)](#그래프-graph)
4. [해시 테이블 (Hash Table)](#해시-테이블-hash-table)
5. [🔥 고급 자료구조 및 알고리즘 (Advanced)](#고급-자료구조-및-알고리즘-advanced)

---

## 🌳 트리 구조 (Trees)

### 이진 탐색 트리 (Binary Search Tree)

- **파일**: `bst.c`
- **구현 기능**:
  - `insertTreeNode()`: 새로운 노드를 올바른 위치에 삽입
  - `deleteTreeNode()`: 노드 삭제 (degree 0, 1, 2 경우 모두 처리)
    - Degree 0: 리프 노드 직접 삭제
    - Degree 1: 자식 노드로 대체
    - Degree 2: 후계자(successor) 찾아 대체
  - `printTreeInorder()`: 중위 순회로 정렬된 순서 출력
  - `splitTree()`: 주어진 키를 기준으로 트리를 3개로 분할
  - `threeWayJoin()`: 3개의 서브트리를 하나로 결합
- **핵심 개념**: 왼쪽 자식 < 부모 < 오른쪽 자식 순서 유지

### 📍 **Red-Black 트리 (Red-Black Tree)** ⭐⭐⭐

- **파일**: `RedBlack_tree.c`
- **구현 기능**:
  - `createNode()`: 새 노드 생성 (기본 색상: RED)
  - `insert()`: BST 방식 삽입 후 Red-Black 속성 복구
  - `fixInsert()`: **핵심 함수** - 삽입 후 균형 조정
    - **Case 1**: 삼촌이 빨간색 → 색상 변경으로 해결
    - **Case 2**: z가 삼각형 구조 → 회전으로 Case 3으로 변환
    - **Case 3**: z가 직선 구조 → 회전 + 색상 변경으로 해결
  - 회전 연산:
    - `rotateLeft()`: 좌회전 (Right-Heavy 상황 해결)
    - `rotateRight()`: 우회전 (Left-Heavy 상황 해결)
  - `verifyProperties()`: Red-Black 트리 속성 검증
    - 루트는 검은색
    - 빨간 노드의 자식은 검은색
    - 모든 경로의 검은 노드 수 동일
  - `printTree()`: 레벨별 트리 구조 시각화 (색상 포함)
- **🔥 핵심 개념**:
  - **자동 균형 조정**: 최악의 경우에도 O(log n) 보장
  - **색상 기반 균형**: 빨간색/검은색으로 높이 균형 유지
  - **실제 사용**: C++ STL map, Java TreeMap의 내부 구현

### B-트리 (B-Tree)

- **파일**: `btree.c`
- **구현 기능**:
  - `initBTNode()`: 새로운 B-트리 노드 초기화
  - `BTInsert()`: 키 삽입 (리프 노드와 내부 노드 처리)
  - `splitChild()`: 노드가 가득 찬 경우 분할 처리
    - 중간 키를 부모로 승격
    - 좌우 키들을 별도 노드로 분리
  - `inorderTraversal()`: B-트리 구조 출력 (레벨별 표시)
- **핵심 개념**: 3-Way B-Tree, 디스크 기반 데이터베이스 최적화, 균형 유지

---

## 📊 힙 (Heap)

### 최대 힙 (Max Heap)

- **파일**: `heap.c`
- **구현 기능**:
  - `initHeap()`: 힙 초기화 및 배열 초기화
  - `insertData()`: 새 데이터 삽입 후 상향 조정 (up-heap)
    - 마지막 위치에 삽입 후 부모와 비교하며 위치 조정
    - 부모 노드보다 클 경우 교환 반복
  - `deleteData()`: 루트 노드 삭제 후 하향 조정 (down-heap)
    - 마지막 노드를 루트로 이동
    - 자식들과 비교하며 큰 자식과 교환
  - `printHeap()`: 힙을 레벨별로 시각적 출력
    - 각 레벨이 새로운 줄에 표시되도록 구현
- **핵심 개념**: 완전 이진 트리, 부모 ≥ 자식 관계 유지, 배열 기반 구현

**배열 인덱스 관계**:

- 부모: `i/2`
- 왼쪽 자식: `2*i`
- 오른쪽 자식: `2*i+1`

---

## 🕸️ 그래프 (Graph)

### 그래프 기본 구조

- **표현 방식**: 인접 행렬 (Adjacency Matrix)
- **구현 기능**:
  - `init()`: 그래프 초기화 (모든 간선을 0으로 설정)
  - `insertVertex()`: 새로운 정점 추가
  - `insertEdge()`: 두 정점 간 무방향 간선 추가
- **크기**: 최대 10개 정점

### 깊이 우선 탐색 (DFS)

- **파일**: `graph_dfs.c`
- **구현 기능**:
  - `dfs()`: 재귀 방식 깊이 우선 탐색
    - 현재 정점 방문 표시 및 출력
    - 인접한 미방문 정점들에 대해 재귀 호출
    - visited 배열로 방문 상태 관리
- **특징**: 스택 구조 (재귀), 깊이 우선 탐색

### 너비 우선 탐색 (BFS)

- **파일**: `graph_bfs.c`
- **구현 기능**:
  - `bfs()`: 큐를 이용한 너비 우선 탐색
    - 시작 정점을 큐에 삽입하고 방문 표시
    - 큐에서 정점을 꺼내 출력하고 인접 정점들을 큐에 추가
  - 원형 큐 구현:
    - `initQueue()`: 큐 초기화
    - `enqueue()`: 큐에 데이터 삽입
    - `dequeue()`: 큐에서 데이터 제거
    - `isEmpty()`, `isFull()`: 큐 상태 확인
- **특징**: 큐 구조, 레벨별 탐색, 최단 경로 탐색

### 📍 **다익스트라 알고리즘 (Dijkstra's Algorithm)** ⭐⭐⭐

- **파일**: `Dijkstra_graph.c`
- **구현 기능**:
  - `dijkstra()`: **핵심 알고리즘** - 시작 정점에서 모든 정점까지의 최단 경로 계산
    - **그리디 방식**: 매 단계마다 최소 거리 정점 선택
    - **거리 완화**: 새로운 경로가 더 짧으면 거리 갱신
    - **경로 추적**: predecessor 배열로 실제 경로 저장
  - `choose_vertex()`: 미방문 정점 중 최소 거리 정점 찾기
  - `print_path()`: 재귀적으로 최단 경로 출력
  - `create_sample_graph()`: 테스트용 가중치 그래프 생성
  - 그래프 관리:
    - `init_graph()`: 인접 행렬 초기화 (INF로 설정)
    - `insert_edge()`: 무방향 가중치 간선 추가
    - `print_graph()`: 인접 행렬 시각화
  - **단계별 시각화**: 알고리즘 수행 과정을 테이블로 출력
- **🔥 핵심 개념**:
  - **최단 경로 문제**: 음이 아닌 가중치에서 최적해 보장
  - **시간복잡도**: O(V²) - 인접 행렬 사용
  - **실제 사용**: GPS 네비게이션, 네트워크 라우팅, 게임 AI

### 최소 신장 트리 (MST)

- **파일**: `prim_algorithm.c`
- **구현 기능**:
  - `prim()`: 프림 알고리즘으로 MST 구성
    - 시작 정점부터 그리디 방식으로 확장
    - 현재 MST에 포함된 정점들과 연결된 최소 비용 간선 선택
  - `getMinVertex()`: MST에 포함되지 않은 정점 중 최소 거리 정점 반환
  - 가중치 그래프를 인접 행렬로 표현 (INF로 비연결 표시)
- **시간복잡도**: O(V²)
- **핵심 개념**: 그리디 알고리즘, 최소 비용으로 모든 정점 연결

---

## 🔗 해시 테이블 (Hash Table)

### 체이닝 방식 해시 테이블

- **파일**: `hash_table.c`
- **구현 기능**:
  - `initTable()`: 해시 테이블 초기화 (모든 포인터를 NULL로 설정)
  - `addHashTable()`: 새 요소 삽입
    - 중복 키 검사 수행
    - 체이닝 방식으로 같은 해시값 요소들을 연결 리스트로 관리
    - 새 노드를 리스트 맨 앞에 삽입
  - `hashSearch()`: 키를 이용한 요소 탐색
    - 해당 해시값의 연결 리스트를 순회하며 키 비교
    - 탐색 성공/실패 메시지 출력
  - `printHashTable()`: 전체 해시 테이블 상태 출력
    - 각 인덱스별 연결 리스트 내용을 시각적으로 표시
  - 해시 함수 구현:
    - `transform()`: 문자열의 ASCII 값 합산
    - `hashFunction()`: 결과를 테이블 크기로 나눈 나머지
- **충돌 해결**: 체이닝 (연결 리스트)
- **테이블 크기**: 5개 슬롯

**해시 함수 동작 예시**:

```c
// "Hello" -> ASCII 합: 72+101+108+108+111 = 500
// 500 % 5 = 0 (인덱스 0에 저장)
int hashFunction(char *key) {
    return transform(key) % TABLE_SIZE;
}
```

**사용자 인터페이스**:

- 0: 요소 추가
- 1: 요소 탐색
- 2: 전체 테이블 출력
- 3: 프로그램 종료

---

## 🔥 고급 자료구조 및 알고리즘 (Advanced)

### 📍 **Red-Black 트리 (Red-Black Tree)** ⭐⭐⭐

- **파일**: `RedBlack_tree.c`
- **구현 기능**:
  - `createNode()`: 새 노드 생성 (기본 색상: RED)
  - `insert()`: BST 방식 삽입 후 Red-Black 속성 복구
  - `fixInsert()`: **핵심 함수** - 삽입 후 균형 조정
    - **Case 1**: 삼촌이 빨간색 → 색상 변경으로 해결
    - **Case 2**: z가 삼각형 구조 → 회전으로 Case 3으로 변환
    - **Case 3**: z가 직선 구조 → 회전 + 색상 변경으로 해결
  - 회전 연산:
    - `rotateLeft()`: 좌회전 (Right-Heavy 상황 해결)
    - `rotateRight()`: 우회전 (Left-Heavy 상황 해결)
  - `verifyProperties()`: Red-Black 트리 속성 검증
    - 루트는 검은색
    - 빨간 노드의 자식은 검은색
    - 모든 경로의 검은 노드 수 동일
  - `printTree()`: 레벨별 트리 구조 시각화 (색상 포함)
- **🔥 핵심 개념**:
  - **자동 균형 조정**: 최악의 경우에도 O(log n) 보장
  - **색상 기반 균형**: 빨간색/검은색으로 높이 균형 유지
  - **실제 사용**: C++ STL map, Java TreeMap의 내부 구현

### 📍 **다익스트라 알고리즘 (Dijkstra's Algorithm)** ⭐⭐⭐

- **파일**: `Dijkstra_graph.c`
- **구현 기능**:
  - `dijkstra()`: **핵심 알고리즘** - 시작 정점에서 모든 정점까지의 최단 경로 계산
    - **그리디 방식**: 매 단계마다 최소 거리 정점 선택
    - **거리 완화**: 새로운 경로가 더 짧으면 거리 갱신
    - **경로 추적**: predecessor 배열로 실제 경로 저장
  - `choose_vertex()`: 미방문 정점 중 최소 거리 정점 찾기
  - `print_path()`: 재귀적으로 최단 경로 출력
  - `create_sample_graph()`: 테스트용 가중치 그래프 생성
  - 그래프 관리:
    - `init_graph()`: 인접 행렬 초기화 (INF로 설정)
    - `insert_edge()`: 무방향 가중치 간선 추가
    - `print_graph()`: 인접 행렬 시각화
  - **단계별 시각화**: 알고리즘 수행 과정을 테이블로 출력
- **🔥 핵심 개념**:
  - **최단 경로 문제**: 음이 아닌 가중치에서 최적해 보장
  - **시간복잡도**: O(V²) - 인접 행렬 사용
  - **실제 사용**: GPS 네비게이션, 네트워크 라우팅, 게임 AI

---

## 📝 주요 특징

### 시간 복잡도 비교

| 자료구조/알고리즘  | 삽입            | 삭제            | 탐색            | 특징               |
| ------------------ | --------------- | --------------- | --------------- | ------------------ |
| BST                | O(log n) ~ O(n) | O(log n) ~ O(n) | O(log n) ~ O(n) | 불균형 가능        |
| AVL Tree           | O(log n)        | O(log n)        | O(log n)        | 엄격한 균형        |
| **Red-Black Tree** | **O(log n)**    | **O(log n)**    | **O(log n)**    | **실용적 균형**    |
| B-Tree             | O(log n)        | O(log n)        | O(log n)        | 디스크 최적화      |
| Heap               | O(log n)        | O(log n)        | O(n)            | 우선순위 큐        |
| Hash Table         | O(1) ~ O(n)     | O(1) ~ O(n)     | O(1) ~ O(n)     | 평균 O(1)          |
| **Dijkstra**       | -               | -               | -               | **O(V²) 최단경로** |

### 공간 복잡도

- **트리 구조**: O(n)
- **그래프 (인접 행렬)**: O(V²)
- **해시 테이블**: O(n)
- **Red-Black Tree**: O(n) + 색상 정보
- **Dijkstra**: O(V) - 거리/방문/경로 배열

### 🎯 각 자료구조의 적용 분야

- **BST/AVL**: 동적 정렬, 범위 검색
- **🔥 Red-Black Tree**: **STL map/set, Java TreeMap** (실제 라이브러리 구현)
- **B-Tree**: 데이터베이스 인덱싱, 파일 시스템
- **Heap**: 우선순위 큐, 힙 정렬
- **Graph**: 네트워크 경로, 소셜 네트워크 분석
- **🔥 Dijkstra**: **GPS 네비게이션, 네트워크 라우팅**
- **Hash Table**: 캐시, 데이터베이스 해싱
