# 자료구조 및 알고리즘 구현 모음

이 저장소는 C언어로 구현한 다양한 자료구조와 알고리즘을 포함합니다.

## 📚 목차

1. [트리 구조 (Trees)](#트리-구조-trees)
2. [힙 (Heap)](#힙-heap)
3. [그래프 (Graph)](#그래프-graph)
4. [해시 테이블 (Hash Table)](#해시-테이블-hash-table)

---

## 🌳 트리 구조 (Trees)

### 이진 탐색 트리 (Binary Search Tree)

- **파일**: `bst.c`
- **구현 기능**:
  - `insertTreeNode()`: 새로운 노드를 올바른 위치에 삽입
  - `deleteTreeNode()`: 노드 삭제 (degree 0, 1, 2 경우 모두 처리)
    - Degree 0: 리프 노드 직접 삭제
    - Degree 1: 자식 노드로 대체
    - Degree 2: 후계자(successor) 찾아 대체
  - `printTreeInorder()`: 중위 순회로 정렬된 순서 출력
  - `splitTree()`: 주어진 키를 기준으로 트리를 3개로 분할
  - `threeWayJoin()`: 3개의 서브트리를 하나로 결합
- **핵심 개념**: 왼쪽 자식 < 부모 < 오른쪽 자식 순서 유지

### AVL 트리 (AVL Tree)

- **파일**: `avl_tree.c`
- **구현 기능**:
  - `avlAdd()`: 삽입 후 자동 균형 조정
  - `height()`: 노드의 높이 계산
  - `rotateLL()`: Left-Left 케이스 회전
  - `rotateRR()`: Right-Right 케이스 회전
  - `rotateLR()`: Left-Right 케이스 회전 (이중 회전)
  - `rotateRL()`: Right-Left 케이스 회전 (이중 회전)
  - `avlSearch()`: 균형 트리에서의 효율적 탐색
  - `inorderTraveling()`: 중위 순회 출력
- **핵심 개념**: 모든 노드에서 좌우 서브트리 높이 차이 ≤ 1, 자동 리밸런싱

### B-트리 (B-Tree)

- **파일**: `btree.c`
- **구현 기능**:
  - `initBTNode()`: 새로운 B-트리 노드 초기화
  - `BTInsert()`: 키 삽입 (리프 노드와 내부 노드 처리)
  - `splitChild()`: 노드가 가득 찬 경우 분할 처리
    - 중간 키를 부모로 승격
    - 좌우 키들을 별도 노드로 분리
  - `inorderTraversal()`: B-트리 구조 출력 (레벨별 표시)
- **핵심 개념**: 3-Way B-Tree, 디스크 기반 데이터베이스 최적화, 균형 유지

---

## 📊 힙 (Heap)

### 최대 힙 (Max Heap)

- **파일**: `heap.c`
- **구현 기능**:
  - `initHeap()`: 힙 초기화 및 배열 초기화
  - `insertData()`: 새 데이터 삽입 후 상향 조정 (up-heap)
    - 마지막 위치에 삽입 후 부모와 비교하며 위치 조정
    - 부모 노드보다 클 경우 교환 반복
  - `deleteData()`: 루트 노드 삭제 후 하향 조정 (down-heap)
    - 마지막 노드를 루트로 이동
    - 자식들과 비교하며 큰 자식과 교환
  - `printHeap()`: 힙을 레벨별로 시각적 출력
    - 각 레벨이 새로운 줄에 표시되도록 구현
- **핵심 개념**: 완전 이진 트리, 부모 ≥ 자식 관계 유지, 배열 기반 구현

**배열 인덱스 관계**:

- 부모: `i/2`
- 왼쪽 자식: `2*i`
- 오른쪽 자식: `2*i+1`

---

## 🕸️ 그래프 (Graph)

### 그래프 기본 구조

- **표현 방식**: 인접 행렬 (Adjacency Matrix)
- **구현 기능**:
  - `init()`: 그래프 초기화 (모든 간선을 0으로 설정)
  - `insertVertex()`: 새로운 정점 추가
  - `insertEdge()`: 두 정점 간 무방향 간선 추가
- **크기**: 최대 10개 정점

### 깊이 우선 탐색 (DFS)

- **파일**: `graph_dfs.c`
- **구현 기능**:
  - `dfs()`: 재귀 방식 깊이 우선 탐색
    - 현재 정점 방문 표시 및 출력
    - 인접한 미방문 정점들에 대해 재귀 호출
    - visited 배열로 방문 상태 관리
- **특징**: 스택 구조 (재귀), 깊이 우선 탐색

### 너비 우선 탐색 (BFS)

- **파일**: `graph_bfs.c`
- **구현 기능**:
  - `bfs()`: 큐를 이용한 너비 우선 탐색
    - 시작 정점을 큐에 삽입하고 방문 표시
    - 큐에서 정점을 꺼내 출력하고 인접 정점들을 큐에 추가
  - 원형 큐 구현:
    - `initQueue()`: 큐 초기화
    - `enqueue()`: 큐에 데이터 삽입
    - `dequeue()`: 큐에서 데이터 제거
    - `isEmpty()`, `isFull()`: 큐 상태 확인
- **특징**: 큐 구조, 레벨별 탐색, 최단 경로 탐색

### 최소 신장 트리 (MST)

- **파일**: `prim_algorithm.c`
- **구현 기능**:
  - `prim()`: 프림 알고리즘으로 MST 구성
    - 시작 정점부터 그리디 방식으로 확장
    - 현재 MST에 포함된 정점들과 연결된 최소 비용 간선 선택
  - `getMinVertex()`: MST에 포함되지 않은 정점 중 최소 거리 정점 반환
  - 가중치 그래프를 인접 행렬로 표현 (INF로 비연결 표시)
- **시간복잡도**: O(V²)
- **핵심 개념**: 그리디 알고리즘, 최소 비용으로 모든 정점 연결

---

## 🔗 해시 테이블 (Hash Table)

### 체이닝 방식 해시 테이블

- **파일**: `hash_table.c`
- **구현 기능**:
  - `initTable()`: 해시 테이블 초기화 (모든 포인터를 NULL로 설정)
  - `addHashTable()`: 새 요소 삽입
    - 중복 키 검사 수행
    - 체이닝 방식으로 같은 해시값 요소들을 연결 리스트로 관리
    - 새 노드를 리스트 맨 앞에 삽입
  - `hashSearch()`: 키를 이용한 요소 탐색
    - 해당 해시값의 연결 리스트를 순회하며 키 비교
    - 탐색 성공/실패 메시지 출력
  - `printHashTable()`: 전체 해시 테이블 상태 출력
    - 각 인덱스별 연결 리스트 내용을 시각적으로 표시
  - 해시 함수 구현:
    - `transform()`: 문자열의 ASCII 값 합산
    - `hashFunction()`: 결과를 테이블 크기로 나눈 나머지
- **충돌 해결**: 체이닝 (연결 리스트)
- **테이블 크기**: 5개 슬롯

**해시 함수 동작 예시**:

```c
// "Hello" -> ASCII 합: 72+101+108+108+111 = 500
// 500 % 5 = 0 (인덱스 0에 저장)
int hashFunction(char *key) {
    return transform(key) % TABLE_SIZE;
}
```

**사용자 인터페이스**:

- 0: 요소 추가
- 1: 요소 탐색
- 2: 전체 테이블 출력
- 3: 프로그램 종료

---

## 📝 주요 특징

### 시간 복잡도 비교

| 자료구조   | 삽입            | 삭제            | 탐색            |
| ---------- | --------------- | --------------- | --------------- |
| BST        | O(log n) ~ O(n) | O(log n) ~ O(n) | O(log n) ~ O(n) |
| AVL Tree   | O(log n)        | O(log n)        | O(log n)        |
| B-Tree     | O(log n)        | O(log n)        | O(log n)        |
| Heap       | O(log n)        | O(log n)        | O(n)            |
| Hash Table | O(1) ~ O(n)     | O(1) ~ O(n)     | O(1) ~ O(n)     |

### 공간 복잡도

- **트리 구조**: O(n)
- **그래프 (인접 행렬)**: O(V²)
- **해시 테이블**: O(n)

---

## 📚 학습 목적

이 구현들은 자료구조와 알고리즘의 기본 개념을 이해하고 실습하기 위한 교육용 코드입니다. 각 자료구조의 특성과 사용 사례를 학습할 수 있습니다.
